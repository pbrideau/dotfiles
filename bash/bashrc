#!/bin/bash
# shellcheck disable=SC1090
declare -a TMUX_HOSTS
if [ -d "$HOME/.bashrc_dir" ]; then
	source "${HOME}/.bashrc_dir/"*
fi

################################################################################
# Automatically start tmux when loging on server in $TMUX_HOSTS
# To add server to this list: TMUX_HOSTS+=('example.com')
# Force no tmux with this hack:
# TERM="no_tmux:$TERM" ssh host

if [[ "$TERM" =~ .*:.* ]]; then
	MY_ENV_OVERRIDE=${TERM%:*}
	TERM=${TERM##*:}
fi
export MY_ENV_OVERRIDE

if [ "$MY_ENV_OVERRIDE" != 'no_tmux' ]; then
	if [ -z "$TMUX" ] && [ -n "$SSH_TTY" ] && [[ $- =~ i ]]; then
		if [[ "${TMUX_HOSTS[*]}" =~ $HOSTNAME ]]; then
			nsess_att="$(tmux list-sessions | grep -c attached)"
			nsess="$(tmux list-sessions | wc -l)"
			if [ "${nsess_att}" -lt "${nsess}" ]; then
				SESSION_TO_ATTACH="$(tmux list-sessions |
					grep -v attached |
					head -1 |
					cut -d ':' -f 1)"
				tmux attach-session -t "$SESSION_TO_ATTACH"
				exit
			else
				tmux new-session
				exit
			fi
		fi
	fi
fi
unset MY_ENV_OVERRIDE
unset SESSION_TO_ATTACH

################################################################################
# Source profile.d if not login shell
if ! shopt -q login_shell; then
	umask 002
	SHELL=/bin/bash
	for i in /etc/profile.d/*.sh; do
		if [ -r "$i" ]; then
			if [ "$PS1" ]; then
				. "$i"
			else
				. "$i" >/dev/null
			fi
		fi
	done
	unset i
fi

################################################################################
# When using tmux:
if [ -n "$TMUX" ]; then
	settitle() {
		printf "\033k%s\033\\" "$1"
	}

	ssh() {
		settitle "$*"
		command ssh "$@"
		settitle "bash"
	}

	#MOTD:
	#tested on tmux >= 1.5
	CURRENT_SESSION_NAME="$(tmux list-panes -a |
		grep "$TMUX_PANE" |
		cut -d : -f 1):"
	for word in $(tmux list-sessions); do
		if [[ "$word" =~ [a-z0-9]+:$ ]]; then
			if [ "$word" = "$CURRENT_SESSION_NAME" ]; then
				echo -e "\033[1m"
			else
				echo -e "\033[0m"
			fi
		fi
		echo -n " $word"
	done
	echo
	echo
	unset CURRENT_SESSION_NAME
fi

################################################################################
# Set variables by OS
if [ -n "$(find /etc -name '*-release' 2>/dev/null)" ]; then
	OS=$(cat /etc/*-release | sort -u)
elif [ -e /etc/os-release ]; then
	OS="$(awk -F= '/^NAME/{print $2}' /etc/os-release)"
else
	OS="$(uname)"
fi

case "$OS" in
	*'Red Hat'*)
		# needs-restarting differ from version to version, check the kernel
		LAST_KERNEL=$(rpm -q --last kernel |
			perl -pe 's/^kernel-(\S+).*/$1/' |
			head -1)
		CURRENT_KERNEL=$(uname -r)
		if [ "$LAST_KERNEL" = "$CURRENT_KERNEL" ]; then
			REBOOT=""
		else
			REBOOT="(reboot) "
		fi
		;;
	*'Debian'*)
		reboot_file1="/var/run/reboot-required"
		reboot_file2="/var/run/reboot-required.pkgs"
		if [ -e "${reboot_file1}" ] || [ -e "${reboot_file2}" ]; then
			REBOOT="(reboot) "
		else
			REBOOT=""
		fi
		;;
	*'Solaris'*)
		REBOOT=""
		NEW_PATH+=('/usr/xpg4/bin')
		;;
	*'CYGWIN'*)
		REBOOT=""
		;;
	*)
		REBOOT="(Unknown OS) "
		;;
esac

function check_ssh_agent {
	if [ -n "$SSH_AUTH_SOCK" ]; then
		if [ -e "$SSH_AUTH_SOCK" ]; then
			return
		fi
	fi

	# Try to use an existing ssh_agent
	declare -a agents
	while IFS= read -r -d $'\0'; do
		agents+=("$REPLY")
	done < <(find /tmp/ssh-* -name 'agent.*' -user "$USER" -print0 2>/dev/null)

	if [ "${#agents[@]}" -gt 0 ]; then
		export SSH_AUTH_SOCK="${agents[0]}"
		if [ "${#agents[@]}" -gt 1 ]; then
			echo "More than one ssh-agent found for $USER, picking one of them"
		fi
	else
		eval "$(ssh-agent -s)"
	fi
}

################################################################################
# BASIC CONFIGS
NEW_PATH+=(
	"$HOME/.local/bin"
)
for x in "${NEW_PATH[@]}"; do
	case ":$PATH:" in
		*":$x:"*) : ;; # already there
		*) PATH="$x:$PATH" ;;
	esac
done
unset NEW_PATH

function refresh_history {
	history -n
	history -w
	history -c
	history -r
}

# are we an interactive shell?
if [ "$PS1" ]; then
	shopt -s histappend # Turn on parallel history
	history -a
	shopt -s checkwinsize # Turn on checkwinsize
	shopt -s cdspell      # Correct minor error in cd command
	shopt -s cmdhist      # Save multiple-line on the same line
	HISTFILE="${HOME}/.bash_history_dir/${HOSTNAME%%.*}"
	HISTCONTROL=ignoreboth:erasedups
	HISTSIZE=10000
	HISTFILESIZE=10000
	unset HISTTIMEFORMAT

	#export PROMPT_COMMAND="refresh_history; $PROMPT_COMMAND"
	if [ -e "$HISTFILE" ]; then
		TEMP_FILE=$(mktemp "$HOME/.bash_history_dir/tmp.XXXXXX")
		tac "$HISTFILE" | awk '!x[$0]++' >"$TEMP_FILE" &&
			tac "$TEMP_FILE" >"$HISTFILE"
		rm "$TEMP_FILE"
		unset TEMP_FILE
	fi
fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
# shellcheck disable=SC1091
if ! shopt -oq posix; then
	if [ -f /usr/share/bash-completion/bash_completion ]; then
		. /usr/share/bash-completion/bash_completion
	elif [ -f /etc/bash_completion ]; then
		. /etc/bash_completion
	fi
fi

################################################################################
# IS THERE PACKAGES TO UPDATES?
if [ -e "$HOME/.update_count" ]; then
	UPDATE_CONTENT=$(cat "$HOME/.update_count")
	if [ "$UPDATE_CONTENT" -eq 0 ]; then
		UPDATE_COUNT=""
	else
		UPDATE_COUNT="($UPDATE_CONTENT) "
	fi
fi
# Crontabs:
# Debian: nice -n 19 aptitude search "~U" | wc -l > $HOME/.update_count
# RedHat: nice -n 19 yum check-update | sed -n "/Obsoleting/q;p" | wc -l | awk '{print $1-3}' > $HOME/.update_count

################################################################################
# PROMPT
if [ -z "$ICON_COLOR" ]; then
	ICON_COLOR="\033[01;32m"
fi

PS1="\n\[\033[31m\]${REBOOT}"
PS1+="\[\033[01;33m\]${UPDATE_COUNT}"
PS1+="\[\033[01;32m\]\h\[${ICON_COLOR}\] >"
PS1+="\[\033[0m\] "
PS1+="\[\033[01;34m\]\w"
PS1+="\[\033[0m\]\n\$ "
SUDO_PS1="\n\[\033[01;41m\]\h"
SUDO_PS1+="\[\033[0m${ICON_COLOR}\] >"
SUDO_PS1+="\[\033[0m\] "
SUDO_PS1+="\[\033[01;34m\]\w"
SUDO_PS1+="\[\033[0m\]\n# "
export SUDO_PS1

################################################################################
# GIT
if [ -f "$HOME/git/bash-git-prompt/gitprompt.sh" ]; then
	export GIT_PROMPT_ONLY_IN_REPO=1
	export GIT_PROMPT_FETCH_REMOTE_STATUS=1
	export GIT_PROMPT_IGNORE_SUBMODULES=0
	export GIT_PROMPT_SHOW_UPSTREAM=1
	export GIT_PROMPT_SHOW_UNTRACKED_FILES=all # can be no, normal or all;
	GIT_PROMPT_START="\n\[\033[31m\]${REBOOT}"
	GIT_PROMPT_START+="\[\033[01;33m\]${UPDATE_COUNT}"
	GIT_PROMPT_START+="\[\033[01;32m\]\h"
	GIT_PROMPT_START+="\[${ICON_COLOR}\] >"
	GIT_PROMPT_START+="\[\033[0m\] "
	GIT_PROMPT_START+="\[\033[01;34m\]\w"
	GIT_PROMPT_START+="\[\033[0m\]"
	export GIT_PROMPT_START
	export GIT_PROMPT_END="\n\$ "

	source "$HOME/git/bash-git-prompt/gitprompt.sh"
fi

alias ga="git add"
alias gc="git commit"
alias gd="git diff"
alias gds="git diff --staged"
alias gco="git checkout"
alias gst="git status"
alias grst="git reset"
alias glh="git log \
	--date=short \
	--format='%C(yellow)%h %Cblue%ad %Cgreen%<|(40)%an%Creset %s ' \
	--follow"
alias glo="git log \
	--graph \
	--date=short \
	--format='%C(yellow)%h %Cblue%ad%C(auto)%d%C(yellow) %Creset%s'"
alias gloa="git log \
	--graph \
	--date=short \
	--format='%C(yellow)%h %Cblue%ad%C(auto)%d%C(yellow) %Creset%s' \
	--all"
#alias glo="git log --oneline --decorate --tags --graph "
#alias gloa="git log --oneline --decorate --tags --graph --all"

export GIT_CEILING_DIRECTORIES="$HOME:/home"

################################################################################
# CHEAT
export CHEAT_CONFIG_PATH="$HOME/.dotfiles/cheat/conf.yml"

################################################################################
# ALIASES
alias tmux='TERM=xterm-256color tmux'
alias genpass="tr -cd '[:alnum:]' < /dev/urandom | fold -w43 | head -n1"

if [ -x /usr/bin/gvim ]; then
	alias vi="vim --servername VIM --remote-tab-silent"
else
	alias vi='vim'
fi

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
	if [ -r ~/.dircolors ]; then
		eval "$(dircolors -b ~/.dircolors)"
	else
		eval "$(dircolors -b)"
	fi
	alias ls='ls --color=auto'
	if grep --color "a" <<<"a" &>/dev/null; then
		alias grep='grep --color=auto'
		alias fgrep='fgrep --color=auto'
		alias egrep='egrep --color=auto'
	fi
fi

alias ll='ls -latr'
alias la='ls -A'
alias l='ls -CF'

alias psgrep='ps auxfww | grep -v grep | grep'
alias nocomment='grep --color=no "^[^ #;]"'

alias ..='cd ..'
alias ...='cd ../..'

################################################################################
# FZF
if [[ "$-" =~ i ]] && [ -d "$HOME/git/fzf" ]; then
	source "$HOME/git/fzf/shell/completion.bash"
	source "$HOME/git/fzf/shell/key-bindings.bash"
fi

################################################################################
# RVM
if [ -s "$HOME/.rvm/scripts/rvm" ]; then
	source "$HOME/.rvm/scripts/rvm"
	# Load RVM into a shell session *as a function*
fi

# vim: ff=sh ts=2 sw=2
