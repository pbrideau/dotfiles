#!/bin/bash
# shellcheck disable=SC1090,SC1091

################################################################################
# Source profile.d if not login shell
if ! shopt -q login_shell; then
	umask 002
	SHELL=/bin/bash
	for i in /etc/profile.d/*.sh; do
		if [ -r "$i" ]; then
			if [ "$PS1" ]; then
				. "$i"
			else
				. "$i" > /dev/null
			fi
		fi
	done
	unset i
fi

if [[ ! "$-" =~ i ]]; then
	return
fi

function add_path {
	# This is the redhat pathmunge()
	if ! echo "$PATH" | grep -E -q "(^|:)$1($|:)"; then
		if [ "$2" = "after" ]; then
			PATH=$PATH:$1
		else
			PATH=$1:$PATH
		fi
	fi
}

################################################################################
# BASIC CONFIGS
if [ -d "$HOME/.local/bin" ]; then
	if [ "$(uname -m)" = "x86_64" ]; then
		add_path "$HOME/.local/bin"
	fi
fi

declare -a TMUX_HOSTS
declare -a AGENT_HOSTS
if [ -d "$HOME/.bashrc_dir" ]; then
	for f in "${HOME}"/.bashrc_dir/*; do
		source "$f"
	done
fi

################################################################################
# Automatically start tmux when loging on server in $TMUX_HOSTS
# To add server to this list: TMUX_HOSTS+=('example.com')
# Force no tmux with this hack:
# TERM="no_tmux:$TERM" ssh host

if [[ "$TERM" =~ .*:.* ]]; then
	MY_ENV_OVERRIDE=${TERM%:*}
	TERM=${TERM##*:}
fi
export MY_ENV_OVERRIDE

if ! infocmp "$TERM" &> /dev/null; then
	# Make sure we do not break vim if screen-256color does not exists
	if [[ "$TERM" =~ screen ]]; then
		if infocmp "screen-256color" &> /dev/null; then
			TERM="screen-256color"
		elif infocmp "screen" &> /dev/null; then
			TERM="screen"
		elif infocmp "xterm" &> /dev/null; then
			TERM="xterm"
		fi
	else
		TERM="xterm"
	fi
fi

alias tmux='tmux -2' # Force 256colors
if [[ "${TMUX_HOSTS[*]}" =~ $HOSTNAME ]]; then
	if [ "$MY_ENV_OVERRIDE" != 'no_tmux' ]; then
		if [ -z "$TMUX" ] && [ -n "$SSH_TTY" ] && [[ $- =~ i ]]; then
			nsess_att="$(tmux list-sessions | grep -c attached)"
			nsess="$(tmux list-sessions | wc -l)"
			if [ "${nsess_att}" -lt "${nsess}" ]; then
				SESSION_TO_ATTACH="$(tmux list-sessions |
					grep -v attached |
					head -1 |
					cut -d ':' -f 1)"
				tmux attach-session -t "$SESSION_TO_ATTACH"
				exit
			else
				tmux new-session
				exit
			fi
		fi
	fi
fi
unset nsess_att nsess
unset MY_ENV_OVERRIDE
unset SESSION_TO_ATTACH

################################################################################
# When using tmux:
if [ -n "$TMUX" ]; then
	#MOTD:
	#tested on tmux >= 1.5
	CURRENT_SESSION_NAME="$(tmux list-panes -a |
		grep "$TMUX_PANE" |
		cut -d : -f 1):"
	for word in $(tmux list-sessions); do
		if [[ "$word" =~ [a-z0-9]+:$ ]]; then
			if [ "$word" = "$CURRENT_SESSION_NAME" ]; then
				echo -e "\033[1m"
			else
				echo -e "\033[0m"
			fi
		fi
		echo -n " $word"
	done
	echo
	echo
	unset CURRENT_SESSION_NAME
fi

################################################################################
# Set variables by OS
if [ -n "$(find /etc -name '*-release' 2> /dev/null)" ]; then
	OS=$(cat /etc/*-release | sort -u)
elif [ -e /etc/os-release ]; then
	OS="$(awk -F= '/^NAME/{print $2}' /etc/os-release)"
else
	OS="$(uname)"
fi

case "$OS" in
	*'Red Hat'*)
		# needs-restarting differ from version to version, check the kernel
		LAST_KERNEL=$(rpm -q --last kernel |
			perl -pe 's/^kernel-(\S+).*/$1/' |
			head -1)
		CURRENT_KERNEL=$(uname -r)
		if [ "$LAST_KERNEL" = "$CURRENT_KERNEL" ]; then
			REBOOT=""
		else
			REBOOT="(reboot) "
		fi
		;;
	*'Debian'*)
		reboot_file1="/var/run/reboot-required"
		reboot_file2="/var/run/reboot-required.pkgs"
		if [ -e "${reboot_file1}" ] || [ -e "${reboot_file2}" ]; then
			REBOOT="(reboot) "
		else
			REBOOT=""
		fi
		;;
	*'Solaris'* | *'SunOS'*)
		REBOOT=""
		;;
	*'CYGWIN'*)
		REBOOT=""
		;;
	*)
		REBOOT="(Unknown OS) "
		;;
esac

function refresh_history {
	#history -n
	#history -w
	#history -c
	#history -r
	history -a
}

# are we an interactive shell?
if [ "$PS1" ]; then
	shopt -s histappend # Turn on parallel history
	#history -a
	shopt -s checkwinsize # Turn on checkwinsize
	shopt -s cdspell      # Correct minor error in cd command
	shopt -s cmdhist      # Save multiple-line on the same line
	HISTFILE="${HOME}/.bash_history_dir/${HOSTNAME%%.*}"
	HISTCONTROL=ignoreboth:erasedups
	HISTSIZE=10000
	HISTFILESIZE=10000
	unset HISTTIMEFORMAT

	export PROMPT_COMMAND="refresh_history;$PROMPT_COMMAND"
	if [ -e "$HISTFILE" ]; then
		if command -v tac &> /dev/null; then
			TEMP_FILE=$(mktemp "$HOME/.bash_history_dir/tmp.XXXXXX")
			tac "$HISTFILE" | awk '!x[$0]++' > "$TEMP_FILE" &&
				tac "$TEMP_FILE" > "$HISTFILE"
			rm "$TEMP_FILE"
			unset TEMP_FILE
		fi
	fi
fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if ! shopt -oq posix; then
	if [ -f /usr/share/bash-completion/bash_completion ]; then
		. /usr/share/bash-completion/bash_completion
	elif [ -f /etc/bash_completion ]; then
		. /etc/bash_completion
	fi
fi

################################################################################
# IS THERE PACKAGES TO UPDATES?
function update_count {
	if [ -e "$HOME/.update_count" ]; then
		declare -i update_content
		update_content=$(cat "$HOME/.update_count")
		if [ "$update_content" -gt 0 ]; then
			echo "($update_content) "
		fi
	fi
}
# Crontabs:
# Debian: nice -n 19 aptitude search "~U" | wc -l > $HOME/.update_count
# RedHat: nice -n 19 yum check-update | sed -n "/Obsoleting/q;p" | wc -l | awk '{print $1-3}' > $HOME/.update_count

function pipchk_count {
	if [ -e "$HOME/.pipchk_count" ]; then
		declare -i pipchk_content
		pipchk_content=$(cat "$HOME/.pipchk_count")
		if [ "$pipchk_content" -gt 0 ]; then
			echo "(pip:$pipchk_content) "
		fi
	fi
}
# Crontabs:
# $HOME/.local/bin/pipchk &>/dev/null

function gitchk_count {
	if [ -e "$HOME/.gitchk_count" ]; then
		declare -i gitchk_content
		gitchk_content=$(cat "$HOME/.gitchk_count")
		if [ "$gitchk_content" -gt 0 ]; then
			echo "(git:$gitchk_content) "
		fi
	fi
}
# Crontabs:
# PATH in crontab must be set to run lastversion (~/.local/bin)
# $HOME/.local/bin/gitchk &>/dev/null

################################################################################
# SSH CONFIG
if [ -d "${HOME}/.ssh/config.d" ]; then
	echo '# AUTOGENERATED during .bashrc load' > ~/.ssh/config
	for i in "$HOME/.ssh/config.d/"*; do
		echo "#$i" >> ~/.ssh/config
		cat "$i" >> ~/.ssh/config
	done
fi

################################################################################
# SSH_AGENT
function check_ssh_agent {
	if [ -n "$SSH_AUTH_SOCK" ]; then
		if [ -e "$SSH_AUTH_SOCK" ]; then
			return
		fi
	fi

	# Try to use an existing ssh_agent
	declare -a agents
	while IFS= read -r -d $'\0'; do
		agents+=("$REPLY")
	done < <(find /tmp/ssh-* -name 'agent.*' -user "$USER" -print0 2> /dev/null)

	if [ "${#agents[@]}" -gt 0 ]; then
		# Pick the first you find
		export SSH_AUTH_SOCK="${agents[0]}"
		export SSH_AGENT_PID="$((${SSH_AUTH_SOCK#*.} + 1))"
		# shellcheck disable=SC2009
		if ! ps -p "$SSH_AGENT_PID" | grep ssh-agent &> /dev/null; then
			#Sometimes, there is no ssh-agent process, but SSH_AUTH_SOCK is managed
			#ForwardAgent ssh_config or MobaXterm
			unset SSH_AGENT_PID
		fi
	else
		eval "$(ssh-agent -s -t 12h)" > /dev/null
		echo -e "\033[01;33mcheck_ssh_agent(): new ssh-agent started\033[0m"
		echo -e "\033[01;33m You can now run \033[01;31mssh-add\033[0m"
	fi
}

# Start ssh-agent on AGENT_HOSTS server list
if [[ "${AGENT_HOSTS[*]}" =~ $HOSTNAME ]]; then
	check_ssh_agent
	if [[ ! "$PROMPT_COMMAND" =~ check_ssh_agent ]]; then
		export PROMPT_COMMAND="check_ssh_agent;$PROMPT_COMMAND"
	fi
fi

# Notify if more than one agent is running
declare -a agents
while IFS= read -r -d $'\0'; do
	agents+=("$REPLY")
done < <(find /tmp/ssh-* -name 'agent.*' -user "$USER" -print0 2> /dev/null)

if [ "${#agents[@]}" -gt 1 ]; then
	echo -e "\033[01;33mMore than one ssh-agent running\033[0m"
fi
unset agents

function prompt_ssh_agent {
	if [ -e "$SSH_AUTH_SOCK" ]; then
		echo -n "@"
		if ssh-add -l &> /dev/null; then
			echo -n "+"
		fi
		echo -n " "
	fi
}
#PROMPT_SSH_AGENT="test -e \"\$SSH_AUTH_SOCK\" && echo -n \"@\""
#PROMPT_SSH_AGENT+="&& \$(ssh-add -l &>/dev/null) && echo -n \"+\""
# You can add this to ~/.ssh/config:
#      Host SERVERNAME
#      ForwardAgent yes

################################################################################
# PROMPT
if [ -z "$HOSTNAME_COLOR" ]; then
	HOSTNAME_COLOR="\033[01;32m"
fi

function prompt_line {
	printf %${COLUMNS:-$(tput cols)}s | tr " " "-"
}

function prompt_goto_eol {
	printf "\033[%sC" "${COLUMNS:-$(tput cols)}"
}

PS1="\[\033[0m\]\n"
PS1+="\[\033[s\]" #save cursor position
PS1+="\$(prompt_line)"
PS1+="\[\033[u\]" # restore cursor position

### Display current time on right hand side
PS1+="\[\033[s\]" #save cursor position
PS1+="\$(prompt_goto_eol)"
PS1+="\[\033[15D\]" #go back 15 char
PS1+="\[\033[0m\][ \[\033[1;33m\]\D{%b %d %R}\[\033[0m\] ]"
PS1+="\[\033[u\]" # restore cursor position

PS1+="\[\033[0m\][ "
PS1+="\[\033[01;31m\]\$(prompt_ssh_agent)"
if [ "$REBOOT" != "" ]; then
	PS1+="\[\033[31m\]${REBOOT}"
fi
if [ -e "$HOME/.update_count" ]; then
	PS1+="\[\033[01;33m\]\$(update_count)"
fi
if [ -e "$HOME/.pipchk_count" ]; then
	PS1+="\[\033[01;33m\]\$(pipchk_count)"
fi
if [ -e "$HOME/.gitchk_count" ]; then
	PS1+="\[\033[01;33m\]\$(gitchk_count)"
fi
PS1+="\[\033[0m\]]"

#PS1+="\[\033[01;33m\]\t"
PS1+="\n"
PS1+="\[\033[01;32m\]\u\[\033[1;0m\]@"
PS1+="\[\033[${HOSTNAME_COLOR}\]\h\[\033[0m\]:"
PS1+="\[\033[01;34m\]\w"
PS1+="\[\033[0m\]\n\$ "

SUDO_PS1="\[\033[0m\]\n"
SUDO_PS1+="\[\033[01;31m\]\u\[\033[1;0m\]@"
SUDO_PS1+="\[\033[${HOSTNAME_COLOR}\]\h\[\033[0m\]:"
SUDO_PS1+="\[\033[01;34m\]\w"
SUDO_PS1+="\[\033[0m\]\n# "
export SUDO_PS1

################################################################################
# GIT
if [ -f "$HOME/git/bash-git-prompt/gitprompt.sh" ]; then
	export GIT_PROMPT_ONLY_IN_REPO=1
	export GIT_PROMPT_FETCH_REMOTE_STATUS=1
	export GIT_PROMPT_IGNORE_SUBMODULES=0
	export GIT_PROMPT_SHOW_UPSTREAM=1
	export GIT_PROMPT_SHOW_UNTRACKED_FILES=all # can be no, normal or all;

	GIT_PROMPT_START="\[\033[0m\]\n"
	GIT_PROMPT_START+="\[\033[s\]" #save cursor position
	GIT_PROMPT_START+="\$(prompt_line)"
	GIT_PROMPT_START+="\[\033[u\]" # restore cursor position

	### Display current time on right hand side
	GIT_PROMPT_START+="\[\033[s\]" #save cursor position
	GIT_PROMPT_START+="\$(prompt_goto_eol)"
	GIT_PROMPT_START+="\[\033[15D\]" #go back 15 char
	GIT_PROMPT_START+="\[\033[0m\][ \[\033[1;33m\]\D{%b %d %R}\[\033[0m\] ]"
	GIT_PROMPT_START+="\[\033[u\]" # restore cursor position

	GIT_PROMPT_START+="\[\033[0m\][ "
	GIT_PROMPT_START+="\[\033[01;31m\]\$(prompt_ssh_agent)"
	if [ "$REBOOT" != "" ]; then
		GIT_PROMPT_START+="\[\033[31m\]${REBOOT}"
	fi
	if [ -e "$HOME/.update_count" ]; then
		GIT_PROMPT_START+="\[\033[01;33m\]\$(update_count)"
	fi
	if [ -e "$HOME/.pipchk_count" ]; then
		GIT_PROMPT_START+="\[\033[01;33m\]\$(pipchk_count)"
	fi
	if [ -e "$HOME/.gitchk_count" ]; then
		GIT_PROMPT_START+="\[\033[01;33m\]\$(gitchk_count)"
	fi
	GIT_PROMPT_START+="\[\033[0m\]]"

	GIT_PROMPT_END="\n"
	GIT_PROMPT_END+="\[\033[01;32m\]\u\[\033[1;0m\]@"
	GIT_PROMPT_END+="\[\033[${HOSTNAME_COLOR}\]\h\[\033[0m\]:"
	GIT_PROMPT_END+="\[\033[01;34m\]\w"
	GIT_PROMPT_END+="\[\033[0m\]\n\$ "

	export GIT_PROMPT_START
	export GIT_PROMPT_END

	source "$HOME/git/bash-git-prompt/gitprompt.sh"
fi

alias ga="git add"
alias gc="git commit"
alias gd="git diff"
alias gds="git diff --staged"
alias gco="git checkout"
alias gst="git status"
alias grst="git reset"
alias glh="git log \
	--date=short \
	--format='%C(yellow)%h %Cblue%ad %Cgreen%<|(40)%an%Creset %s ' \
	--follow"
alias glo="git log \
	--graph \
	--date=short \
	--format='%C(yellow)%h %Cblue%ad %Cgreen%an %C(auto)%d%C(yellow) %Creset%s'"
alias gloa="git log \
	--graph \
	--date=short \
	--format='%C(yellow)%h %Cblue%ad %Cgreen%an %C(auto)%d%C(yellow) %Creset%s' \
	--all"
#alias glo="git log --oneline --decorate --tags --graph "
#alias gloa="git log --oneline --decorate --tags --graph --all"

export GIT_CEILING_DIRECTORIES="$HOME:/home"
export GIT_EDITOR=vim
export GIT_PAGER='less -R'

################################################################################
# CHEAT
export CHEAT_CONFIG_PATH="$HOME/.dotfiles/cheat/conf.yml"
export CHEAT_USE_FZF=true
if [ -e "$HOME/git/cheat/script/cheat.bash" ]; then
	source "$HOME/git/cheat/scripts/cheat.bash"
fi

################################################################################
# TLDR
complete -W "$(tldr 2> /dev/null --list)" tldr
export TLDR_HEADER='magenta bold underline'
export TLDR_QUOTE='italic'
export TLDR_DESCRIPTION='green'
export TLDR_CODE='red'
export TLDR_PARAM='blue'

################################################################################
# ALIASES
alias genpass="tr -cd '[:alnum:]' < /dev/urandom | fold -w43 | head -n1"

if [ -x /usr/bin/gvim ]; then
	alias vi="vim --servername VIM --remote-tab-silent"
else
	alias vi='vim'
fi

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
	if [ -r ~/.dircolors ]; then
		eval "$(dircolors -b ~/.dircolors)"
	else
		eval "$(dircolors -b)"
	fi
	alias ls='ls --color=auto'
	if grep --color "a" <<< "a" &> /dev/null; then
		alias grep='grep --color=auto'
		alias fgrep='fgrep --color=auto'
		alias egrep='egrep --color=auto'
	fi
fi

alias ll='ls -latr'
alias la='ls -A'
alias l='ls -CF'

alias psgrep='ps auxfww | grep -v grep | grep'
alias nocomment='grep --color=no "^[^#;$]"'

alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'

if ! command -v lsof &> /dev/null; then
	message="\033[01;33m Running \033[01;31mfuser -cu"
	message+="\033[01;33m as lsof does not exists on this system\033[0m"

	# shellcheck disable=SC2139
	# I know the $message variable is expanded when defined, this is what i want
	alias lsof="echo;echo -e \"$message\";echo; fuser -cu"
	unset message
fi

################################################################################
# COLORED MANPAGES
function man {
	LESS_TERMCAP_md=$'\e[01;31m' \
		LESS_TERMCAP_me=$'\e[0m' \
		LESS_TERMCAP_se=$'\e[0m' \
		LESS_TERMCAP_so=$'\e[01;44;33m' \
		LESS_TERMCAP_ue=$'\e[0m' \
		LESS_TERMCAP_us=$'\e[01;32m' \
		command man "$@"
}

################################################################################
# FZF
if [[ "$-" =~ i ]]; then
	if [ -d "$HOME/git/fzf" ]; then
		source "$HOME/git/fzf/shell/completion.bash"
		source "$HOME/git/fzf/shell/key-bindings.bash"
	elif [ -e "/usr/share/doc/fzf/examples/key-bindings.bash" ]; then
		source /usr/share/doc/fzf/examples/key-bindings.bash
	fi
fi

################################################################################
# RVM
if [ -s "$HOME/.rvm/scripts/rvm" ]; then
	source "$HOME/.rvm/scripts/rvm"
	# Load RVM into a shell session *as a function*
fi

unset add_path
# vim: ff=sh ts=2 sw=2
