== Skeleton.script-set == nomenu, below ==
# new-script.templates - 2020-11-19

set -o nounset     # Treat unset variable as an error
shopt -s extglob   # Extended pattern matching

################################################################################
# Why doesn't set -e (or set -o errexit, or trap ERR) do what I expected?
# http://mywiki.wooledge.org/BashFAQ/105
#set -e             # Stop execution if there is an error
#set -o pipefail    # pass the error to the rightmost element when pipe

if [ -f common.sh ]; then
	# shellcheck disable=SC1091
	source common.sh
fi

################################################################################
# Return codes
# Limit user-defined exit codes to the range 64-113
# See /usr/include/sysexits.h for common examples
export EX_USAGE=64
export EX_NOTFOUND=127

################################################################################
# Dependency
if ! command -v getopt &>/dev/null; then
	echo "This script require getopt, please install it"
	exit "$EX_NOTFOUND"
fi

################################################################################
# USAGE
function usage
{
	echo "Usage: $BASENAME [options] command"
	echo
	echo "Examples:"
	echo "  $BASENAME -b foobar run"
	echo
	echo "Options:"
	echo "   -h, --help                Show this message"
	echo "   -d, --debug               Show debug log"
	echo "   -v, --verbose             Show verbose log (multiple -v is --debug)"
	echo "   -q, --quiet               Show only error logs (default warn)"
	echo "   -y, --yes                 Answer YES to every questions asked"
	echo "   --no-colors               Disable colored output"
	echo "   --parseable               Make output easier to parse"
	echo
	echo "   -f, --foo                 Do foo"
	echo "   -b, --bar=BAZ             Do bar with BAZ"
	echo
	echo "Commands:"
	echo "   run                       Run the program"
}

################################################################################
# MAIN
function main
{
	log 3 "========== function ${FUNCNAME[0]}"
	log 3 "config_file: $CONFIG_FILE"
	prompt_user_abort "Do you want to continue?"
	sleep 5 &
	spinner $! sleeping

	log 3 "This show a debug to stdout, when --debug"
	log 2 "This show an info to stdout, when --verbose"
	log 1 "This show a warning to stdout"
	log 0 "This show an error to stderr"
}

function validate_inputs
{
	log 3 "========== function ${FUNCNAME[0]}"
	log 3 "var_a: $VAR_A"
	log 3 "var_b: $VAR_B"
}

trap sigusr1 SIGUSR1
function sigusr1
{
	# Trigger this with kill -s USR1 <pid>
	echo
	log 3 "Signal SIGUSR1 received"
}

################################################################################
# INTERNAL FUNCTION (might want to put in common.sh)
declare -i LOG_LEVEL=1
declare -A LOG_LEVELS=(
	[0]="error"
	[1]="warn "
	[2]="info "
	[3]="debug"
)
function log
{
	# Log to stdout or stderr
	# Usage:
	#   log N "MESSAGE"
	#   Where N is [0-3]
	#   log 0 "This is an error log"
	local level=${1}
	local color=""
	shift
	case $level in
		0)
			color="$txtred";;
		1)
			color="$txtylw";;
		2)
			color="$txtgrn";;
		3)
			color="$txtblu";;
	esac

	# shellcheck disable=SC2153 # No misspelling here
	if [ "$LOG_LEVEL" -ge "$level" ]; then
		if [ "$level" -eq 0 ]; then
			echo -e "[${color}${LOG_LEVELS[$level]}${txtrst}]" "$@" 1>&2
		else
			echo -e "[${color}${LOG_LEVELS[$level]}${txtrst}]" "$@"
		fi
	fi
}

function prompt_user_abort
{
	# Ask user if he want to continue
	# Usage:
	#   prompt_user_abort
	#       or
	#   prompt_user_abort "QUESTION"
	log 3 "========== function ${FUNCNAME[0]}"
	local question="Are you sure?"
	local response
	if [ $# -gt 0 ]; then
		question=$1
	fi
	question="${question} [y/N] "
	if [ "$ALWAYS_YES" = false ]; then
		read -r -p "$question" response
		case "$response" in
			[yY][eE][sS]|[yY])
				;;
			*)
				log 0 "Aborting..."
				exit 1
				;;
		esac
	fi
}

function spinner
{
	# Start a notification while task is running in background
	# Usage:
	#   sleep 10 &
	#   .sleeper $! job_name
	log 3 "========== function ${FUNCNAME[0]}"
	local job=$1
	local process_name
	if [ $# -gt 1 ]; then
		process_name=$2
	else
		process_name=$(ps -q "$job" -o comm=)
	fi
	local spinstr='\|/-'
	local start_time=$SECONDS
	local temp

	log 3 "background job pid: $job"
	if [ "$PARSEABLE" = true ]; then
		log 1 "running: $process_name"
	fi
	while ps -q "$job" &>/dev/null; do
		if [ "$LOG_LEVEL" -ne 0 ]; then
			if [ "$PARSEABLE" = true ]; then
				echo -n '.'
			else
				temp="${spinstr#?}"
				printf "${txtcr}[${txtylw}warn ${txtrst}] running: %s (%ds) %c" "$process_name" "$((SECONDS-start_time))" "${spinstr}"
				spinstr=${temp}${spinstr%"$temp"}
			fi
		fi
		sleep 1
	done
	if [ "$LOG_LEVEL" -ne 0 ]; then
		echo
	fi
}

function set_colors
{
	txtund=$(tput sgr 0 1)          # Underline
	txtbld=$(tput bold)             # Bold
	txtrst=$(tput sgr0)             # Reset
	txtcr=$(tput cr)                # Carriage return (start of line)
	txtblk=; txtred=; txtgrn=; txtylw=; txtblu=; txtpur=; txtcyn=; txtwht=;
	bldblk=${txtbld};
	bldred=${txtbld};
	bldgrn=${txtbld};
	bldylw=${txtbld};
	bldblu=${txtbld};
	bldpur=${txtbld};
	bldcyn=${txtbld};
	bldwht=${txtbld};
	if [ "$COLORS" = true ]; then
		ncolors=$(tput colors)
		if [ -n "$ncolors"  ] && [ "$ncolors" -ge 8 ]; then
			txtblk=$(tput setaf 0)
			txtred=$(tput setaf 1)
			txtgrn=$(tput setaf 2)
			txtylw=$(tput setaf 3)
			txtblu=$(tput setaf 4)
			txtpur=$(tput setaf 5)
			txtcyn=$(tput setaf 6)
			txtwht=$(tput setaf 7)
			bldblk=${txtbld}${txtblk}
			bldred=${txtbld}${txtred}
			bldgrn=${txtbld}${txtgrn}
			bldylw=${txtbld}${txtylw}
			bldblu=${txtbld}${txtblu}
			bldpur=${txtbld}${txtpur}
			bldcyn=${txtbld}${txtcyn}
			bldwht=${txtbld}${txtwht}
		fi
	fi
	export txtund txtbld txtrst txtcr
	export txtblk txtred txtgrn txtylw txtblu txtpur txtcyn txtwht
	export bldblk bldred bldgrn bldylw bldblu bldpur bldcyn bldwht
}

################################################################################
# ARGS PARSE
BASENAME=$(basename "$0")
export COLORS=true
export PARSEABLE=false
ALWAYS_YES=false
#export LOG_LEVEL=1             # Set default log level

VAR_A='default_value'
VAR_B='default_value'

declare -A OPTIONS=(
	['h']='help'
	['d']='debug'
	['v']='verbose'
	['q']='quiet'
	['y']='yes'

	['f']='foo'
	['b:']='bar:'
)
declare -a OPTIONS_NOSHORT=(
	'no-colors'
	'parseable'
)

IFS=','
LONG_OPTIONS="${OPTIONS[*]},${OPTIONS_NOSHORT[*]}"
IFS=''
SHORT_OPTIONS="${!OPTIONS[*]}"
unset IFS

opt=$(getopt -o "$SHORT_OPTIONS" --long "$LONG_OPTIONS" -- "$@")
rc=$?
if [ "$rc" -ne 0 ]; then
	exit "$EX_USAGE"
fi
eval set -- "$opt"
unset opt rc
while true; do
	case "$1" in
		-h | --help)
			usage
			exit 0
			;;
		-d | --debug)
			LOG_LEVEL=3
			;;
		-v | --verbose)
			LOG_LEVEL=$LOG_LEVEL+1
			;;
		-q | --quiet)
			LOG_LEVEL=0
			;;
		-y | --yes)
			ALWAYS_YES=true
			;;
		--no-colors)
			COLORS=false
			;;
		--parseable)
			COLORS=false
			PARSEABLE=true
			;;
		-f | --foo)
			VAR_A='foobar'
			;;
		-b | --bar)
			shift
			VAR_B=$1
			;;
		--)
			shift
			break
			;;
		*)
			echo "No such parameter: '$1'"
			exit "$EX_USAGE"
			;;
	esac
	shift
done

################################################################################
# Start functions
set_colors
if [ $# -gt 0 ]; then
	log 3 "pid: $$"
	validate_inputs
	case "$1" in
		run)
			main
			;;
		*)
			log 0 "No such command: $1"
			log 0 "See --help for more details"
			exit "$EX_USAGE"
			;;
	esac
else
	log 0 "No command given, see --help"
	exit "$EX_USAGE"
fi
== ENDTEMPLATE ==
