== Skeleton.script-set == nomenu, below ==
# new-script.templates - 2020-11-18

set -o nounset     # Treat unset variable as an error
shopt -s extglob   # Extended pattern matching

################################################################################
# Why doesn't set -e (or set -o errexit, or trap ERR) do what I expected?
# http://mywiki.wooledge.org/BashFAQ/105
#set -e             # Stop execution if there is an error
#set -o pipefail    # pass the error to the rightmost element when pipe

if [ -f ./common.sh ]; then
	# shellcheck disable=SC1091
	source ./common.sh
fi

################################################################################
# Return codes
# Limit user-defined exit codes to the range 64-113
# See /usr/include/sysexits.h for common examples
EX_USAGE=64
EX_NOTFOUND=127

################################################################################
# Dependency
if ! command -v getopt &>/dev/null; then
	echo "This script require getopt, please install it"
	exit "$EX_NOTFOUND"
fi

################################################################################
# USAGE
function usage
{
	echo "Usage: $BASENAME [options] command"
	echo
	echo "Examples:"
	echo "  $BASENAME -b foobar run"
	echo
	echo "Options:"
	echo "   -h, --help                Show this message"
	echo "   -d, --debug               Show debug log"
	echo "   -v, --verbose             Show verbose log (multiple -v is --debug)"
	echo "   -q, --quiet               Show only error logs (default warn)"
	echo
	echo "   -f, --foo                 Do foo"
	echo "   -b, --bar=BAZ             Do bar with BAZ"
	echo
	echo "Commands:"
	echo "   run                       Run the program"
}

################################################################################
# MAIN
function main
{
	.log 3 "========== function ${FUNCNAME[0]}"

	.log 0 "This show an error"
	.log 1 "This show a warning"
	.log 2 "This show an info, VAR_A:$VAR_A"
	.log 3 "This show a debug, VAR_B:$VAR_B"
}

function validate_inputs
{
	.log 3 "========== function ${FUNCNAME[0]}"
}

################################################################################
# INTERNAL FUNCTION
declare -A LOG_LEVELS=(
	[0]="error"
	[1]="warn "
	[2]="info "
	[3]="debug"
)
ncolors=$(tput colors)
if [ -n "$ncolors"  ] && [ "$ncolors" -ge 8 ]; then
	COLORIZED_LOG=true
else
	COLORIZED_LOG=false
fi
function .log
{
	# Usage:
	#   .log N "MESSAGE"
	#   Where N is [0-3]
	#   .log 0 "This is an error log"
	local level=${1}
	local color=""
	shift
	if [ "$COLORIZED_LOG" = true ]; then
		case $level in
			0)
				color="\033[31m" ;; # RED
			1)
				color="\033[33m" ;; # YELLOW
			2)
				color="\033[32m" ;; # GREEN
			3)
				color="\033[34m" ;; # BLUE
		esac
	fi

	# shellcheck disable=SC2153 # No misspelling
	if [ "$LOG_LEVEL" -ge "$level" ]; then
		if [ "$level" -eq 0 ]; then
			echo -e "[${color}${LOG_LEVELS[$level]}\033[0m]" "$@" 1>&2
		else
			echo -e "[${color}${LOG_LEVELS[$level]}\033[0m]" "$@"
		fi
	fi
}

function .prompt_user_abort
{
	# Usage:
	#   .prompt_user_abort
	#       or
	#   .prompt_user_abort "QUESTION"
	.log 3 "========== function ${FUNCNAME[0]}"
	local question="Are you sure?"
	local response
	if [ $# -gt 0 ]; then
		question=$1
	fi
	question="${question} [y/N] "
	read -r -p "$question" response
	case "$response" in
		[yY][eE][sS]|[yY])
			;;
		*)
			.log 0 "Aborting..."
			exit 1
			;;
	esac
}

function .spinner
{
	# To start a sleeper while task is in background
	# Usage:
	#   sleep 10 &
	#   .sleeper $! job_name
	.log 3 "========== function ${FUNCNAME[0]}"
	local job=$1
	local process_name
	if [ $# -gt 1 ]; then
		process_name=$2
	else
		process_name=$(ps -q "$job" -o comm=)
	fi
	local spinstr='\|/-'
	local start_time=$SECONDS
	local temp

	.log 3 "background job pid: $job"
	while ps -q "$job" &>/dev/null; do
		if [ "$LOG_LEVEL" -ne 0 ]; then
			temp="${spinstr#?}"
			printf "\r[\033[33mwarn \033[0m] running: %s (%ds) %c" "$process_name" "$((SECONDS-start_time))" "${spinstr}"
			spinstr=${temp}${spinstr%"$temp"}
		fi
		sleep 1
	done
	if [ "$LOG_LEVEL" -ne 0 ]; then
		echo
	fi
}

################################################################################
# ARGS PARSE
declare -i LOG_LEVEL=1
BASENAME=$(basename "$0")
#COLORIZED_LOG=false     # Disable log colors

VAR_A='default_value'
VAR_B='default_value'

declare -A OPTIONS=(
	['h']='help'
	['d']='debug'
	['v']='verbose'
	['q']='quiet'

	['f']='foo'
	['b:']='bar:'
)

IFS=','
LONG_OPTIONS="${OPTIONS[*]}"
IFS=''
SHORT_OPTIONS="${!OPTIONS[*]}"
unset IFS

opt=$(getopt -o "$SHORT_OPTIONS" --long "$LONG_OPTIONS" -- "$@")
rc=$?
if [ "$rc" -ne 0 ]; then
	.log 0 "Getopt error"
	exit "$EX_USAGE"
fi
eval set -- "$opt"
unset opt rc
while true; do
	case "$1" in
		-h | --help)
			usage
			exit 0
			;;
		-d | --debug)
			LOG_LEVEL=3
			;;
		-v | --verbose)
			LOG_LEVEL=$LOG_LEVEL+1
			;;
		-q | --quiet)
			LOG_LEVEL=0
			;;
		-f | --foo)
			VAR_A='foobar'
			;;
		-b | --bar)
			shift
			VAR_B=$1
			;;
		--)
			shift
			break
			;;
		*)
			.log 0 "No such parameter: '$1'"
			exit "$EX_USAGE"
			;;
	esac
	shift
done

################################################################################
# Start functions
if [ $# -gt 0 ]; then
	validate_inputs
	case "$1" in
		run)
			main
			;;
		*)
			.log 0 "No such command: $1"
			.log 0 "See --help for more details"
			exit "$EX_USAGE"
			;;
	esac
else
	.log 0 "No command given, see --help"
	exit "$EX_USAGE"
fi

== ENDTEMPLATE ==
