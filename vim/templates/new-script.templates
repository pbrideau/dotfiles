== Skeleton.script-set == nomenu, below ==
# new-script.templates - 2020-11-22

set -o nounset     # Treat unset variable as an error
shopt -s extglob   # Extended pattern matching

################################################################################
# Why doesn't set -e (or set -o errexit, or trap ERR) do what I expected?
# http://mywiki.wooledge.org/BashFAQ/105
#set -e             # Stop execution if there is an error
#set -o pipefail    # pass the error to the rightmost element when pipe

if [ -f common.sh ]; then
	# shellcheck disable=SC1091
	source common.sh
fi

################################################################################
# Return codes
# Limit user-defined exit codes to the range 64-113
# See /usr/include/sysexits.h for common examples
export EX_USAGE=64       # Command line usage error

################################################################################
# Dependency
if ! command -v getopt &>/dev/null; then
	echo "This script require getopt, please install it"
	exit "$EX_NOTFOUND"
fi

################################################################################
# USAGE
function usage
{
	echo "Usage: $BASENAME [options] command"
	echo
	echo "Examples:"
	echo "  $BASENAME -b foobar run"
	echo
	echo "Options:"
	echo "   -h, --help                Show this message"
	echo "   -d, --debug               Show debug log"
	echo "   -v, --verbose             Show verbose log (multiple -v is --debug)"
	echo "   -q, --quiet               Show only error logs (default warn)"
	echo "   -y, --yes                 Answer YES to every questions asked"
	echo "   -c, --config FILE         Use FILE as config, default:"
	echo "                               1  ./${BASENAME%%.*}.conf"
	echo "                               2  ~/.${BASENAME%%.*}.conf"
	echo "                               3  /etc/${BASENAME%%.*}.conf"
	echo "   --no-colors               Disable colored output"
	echo "   --parseable               Make output easier to parse"
	echo
	echo "   -f, --foo                 Do foo"
	echo "   -b, --bar=BAZ             Do bar with BAZ"
	echo
	echo "Commands:"
	echo "   run                       Run the program"
	echo
	echo "Return codes:"
	echo "  64   EX_USAGE              Command line usage error"
	echo "  125  EX_FAIL               Command itself fail"
	echo "  127  EX_NOTFOUND           File not found"
}

################################################################################
# MAIN
function main
{
	log 3 "========== function ${FUNCNAME[0]}"
	prompt_user_abort "Do you want to continue?"
	sleep 5 &
	spinner $! sleeping

	log 3 "This show a debug to stdout, when --debug"
	log 2 "This show an info to stdout, when --verbose"
	log 1 "This show a warning to stdout"
	log 0 "This show an error to stderr"
}

function validate_inputs
{
	log 3 "========== function ${FUNCNAME[0]}"
	log 3 "var_a: $VAR_A"
	log 3 "var_b: $VAR_B"
}

trap sigusr1 SIGUSR1
function sigusr1
{
	# Trigger this with kill -s USR1 <pid>
	echo
	log 3 "Signal SIGUSR1 received"
}

################################################################################
# INTERNAL FUNCTION (might want to put in common.sh)
declare -i LOG_LEVEL=1
declare -A LOG_LEVELS=(
	[0]="error"
	[1]="warn "
	[2]="info "
	[3]="debug"
)
function log
{
	# Log to stdout or stderr
	# Usage:
	#   log N "MESSAGE"
	#   Where N is [0-3]
	#   log 0 "This is an error log"
	local level=${1}
	local color=""
	shift
	case $level in
		0)
			color="$txtred";;
		1)
			color="$txtylw";;
		2)
			color="$txtgrn";;
		3)
			color="$txtblu";;
	esac

	# shellcheck disable=SC2153 # No misspelling here
	if [ "$LOG_LEVEL" -ge "$level" ]; then
		if [ "$level" -eq 0 ]; then
			echo -e "[${color}${LOG_LEVELS[$level]}${txtrst}]" "$@" 1>&2
		else
			echo -e "[${color}${LOG_LEVELS[$level]}${txtrst}]" "$@"
		fi
	fi
}

function prompt_user_abort
{
	# Ask user if he want to continue
	# Usage:
	#   prompt_user_abort
	#       or
	#   prompt_user_abort "QUESTION"
	log 3 "========== function ${FUNCNAME[0]}"
	local question="Are you sure?"
	local response
	if [ $# -gt 0 ]; then
		question=$1
	fi
	question="${question} [y/N] "
	if [ "$ALWAYS_YES" = false ]; then
		read -r -p "$question" response
		case "$response" in
			[yY][eE][sS]|[yY])
				;;
			*)
				log 0 "Aborting..."
				exit 1
				;;
		esac
	fi
}

function spinner
{
	# Start a notification while task is running in background
	# Usage:
	#   sleep 10 &
	#   .sleeper $! job_name
	log 3 "========== function ${FUNCNAME[0]}"
	local job=$1
	local process_name
	if [ $# -gt 1 ]; then
		process_name=$2
	else
		process_name=$(ps -q "$job" -o comm=)
	fi
	local spinstr='\|/-'
	local start_time=$SECONDS
	local temp

	log 3 "background job pid: $job"
	if [ "$PARSEABLE" = true ]; then
		log 1 "running: $process_name"
	fi
	while ps -q "$job" &>/dev/null; do
		if [ "$LOG_LEVEL" -ne 0 ]; then
			if [ "$PARSEABLE" = true ]; then
				echo -n '.'
			else
				temp="${spinstr#?}"
				printf "${txtcr}[${txtylw}warn ${txtrst}] running: %s (%ds) %c" "$process_name" "$((SECONDS-start_time))" "${spinstr}"
				spinstr=${temp}${spinstr%"$temp"}
			fi
		fi
		sleep 1
	done
	if [ "$LOG_LEVEL" -ne 0 ]; then
		echo
	fi
}

if tty -s; then
	txtund=$(tput sgr 0 1)          # Underline
	txtbld=$(tput bold)             # Bold
	txtrst=$(tput sgr0)             # Reset
	txtcr=$(tput cr)                # Carriage return (start of line)
else
	txtund=; txtbld=; txtrst=; txtcr=;
fi
txtblk=; txtred=; txtgrn=; txtylw=; txtblu=; txtpur=; txtcyn=; txtwht=;
bldblk=${txtbld};
bldred=${txtbld};
bldgrn=${txtbld};
bldylw=${txtbld};
bldblu=${txtbld};
bldpur=${txtbld};
bldcyn=${txtbld};
bldwht=${txtbld};
function set_colors
{
	# Make sure we run as interractive shell, disable colors otherwise
	if ! tty -s; then
		PARSEABLE=true
		COLORS=false
	fi

	if [ "$COLORS" = true ]; then
		local ncolors
		ncolors=$(tput colors)
		if [ -n "$ncolors"  ] && [ "$ncolors" -ge 8 ]; then
			txtblk=$(tput setaf 0)
			txtred=$(tput setaf 1)
			txtgrn=$(tput setaf 2)
			txtylw=$(tput setaf 3)
			txtblu=$(tput setaf 4)
			txtpur=$(tput setaf 5)
			txtcyn=$(tput setaf 6)
			txtwht=$(tput setaf 7)
			bldblk=${txtbld}${txtblk}
			bldred=${txtbld}${txtred}
			bldgrn=${txtbld}${txtgrn}
			bldylw=${txtbld}${txtylw}
			bldblu=${txtbld}${txtblu}
			bldpur=${txtbld}${txtpur}
			bldcyn=${txtbld}${txtcyn}
			bldwht=${txtbld}${txtwht}
		fi
	fi
	export txtund txtbld txtrst txtcr
	export txtblk txtred txtgrn txtylw txtblu txtpur txtcyn txtwht
	export bldblk bldred bldgrn bldylw bldblu bldpur bldcyn bldwht
}

# shellcheck disable=SC2120
function load_config
{
	for f in "${CONFIG_FILES[@]}"; do
		if [ -r "$f" ]; then
			while read -r line; do
				if [[ ! "$line" =~ ^# ]]; then
					eval set -- "--${line}"
					load_arg "$@"
				fi
			done < "$f"
			break
		fi
	done
}

# Reserved return codes
export EX_OK=0           # No error
export EX_ERROR=1        # General error
export EX_BLTIN=2        # Misuse of shell builtins
export EX_TMOUT=124      # Command times out
export EX_FAIL=125       # Command itself fail
export EX_NOEXEC=126     # Command is found but cannot be invoked
export EX_NOTFOUND=127   # Command not found
export EX_INVAL=128      # Invalid argument

# 128+signal (Specific x86)
# see kill -l or man 7 signal
export EX_SIGHUP=129     # Hangup detected on controlling terminal
export EX_SIGINT=130     # Interrupt from keyboard
export EX_SIGQUIT=131    # Quit from keyboard
export EX_SIGILL=132     # Illegal instruction
export EX_SIGTRAP=133    # Trace/breakpoint trap
export EX_SIGABRT=134    # Abort signal from abort(3)
export EX_SIGBUS=135     # Bus error (bad memory access)
export EX_SIGFPE=136     # Floating point exception
export EX_SIGKILL=137    # Kill signal
export EX_SIGUSR1=138    # User-defined signal 1
export EX_SIGSEGV=139    # Invalid memory reference
export EX_SIGUSR2=140    # User-defined signal 2
export EX_SIGPIPE=141    # Broken pipe: write to pipe with no readers
export EX_SIGALRM=142    # Timer signal from alarm(2)
export EX_SIGTERM=143    # Termination signal
export EX_SIGCHLD=145    # Child stopped or terminated
export EX_SIGCONT=146    # Continue if stopped
export EX_SIGSTOP=147    # Stop process
export EX_SIGTSTP=148    # Stop typed at terminal
export EX_SIGTTIN=149    # Terminal input for background process
export EX_SIGTTOU=150    # Terminal output for background process
export EX_SIGURG=151     # Urgent condition on socket (4.2BSD)
export EX_SIGXCPU=152    # CPU time limit exceeded (4.2BSD)
export EX_SIGXFSZ=153    # File size limit exceeded (4.2BSD)
export EX_SIGVTALRM=154  # Virtual alarm click (4.2BSD)
export EX_SIGPROF=155    # Profiling timer expired
export EX_SIGWINCH=156   # Window resize signal (4.3BSD, Sun)
export EX_SIGIO=157      # I/O now possible (4.2BSD)
export EX_SIGPWR=158     # Power failure (System V)
export EX_SIGSYS=159     # Bad system call (SVr4)

################################################################################
# ARGS PARSE
BASENAME=$(basename "$0")
export CONFIG_FILES=("./${BASENAME%%.*}.conf" "${HOME}/.${BASENAME%%.*}.conf" "/etc/${BASENAME%%.*}.conf")
export COLORS=true
export PARSEABLE=false
export ALWAYS_YES=false
#export LOG_LEVEL=1             # Set default log level

VAR_A='default_value'
VAR_B='default_value'

function load_arg
{
	declare -A OPTIONS=(
		['h']='help'
		['d']='debug'
		['v']='verbose'
		['q']='quiet'
		['y']='yes'
		['c:']='config:'

		['f']='foo'
		['b:']='bar:'
	)
	declare -a OPTIONS_NOSHORT=(
		'no-colors'
		'parseable'
	)

	IFS=','
	LONG_OPTIONS="${OPTIONS[*]},${OPTIONS_NOSHORT[*]}"
	IFS=''
	SHORT_OPTIONS="${!OPTIONS[*]}"
	unset IFS

	opt=$(getopt -o "$SHORT_OPTIONS" --long "$LONG_OPTIONS" -- "$@")
	rc=$?
	if [ "$rc" -ne 0 ]; then
		exit "$EX_USAGE"
	fi
	eval set -- "$opt"
	unset opt rc
	while true; do
		case "$1" in
			-h | --help)
				usage
				exit 0
				;;
			-d | --debug)
				LOG_LEVEL=3
				;;
			-v | --verbose)
				LOG_LEVEL=$LOG_LEVEL+1
				;;
			-q | --quiet)
				LOG_LEVEL=0
				;;
			-y | --yes)
				ALWAYS_YES=true
				;;
			--no-colors)
				COLORS=false
				;;
			--parseable)
				COLORS=false
				PARSEABLE=true
				;;
			-c | --config)
				CONFIG_FILES=( "$1" )
				;;
			-f | --foo)
				VAR_A='foobar'
				;;
			-b | --bar)
				shift
				VAR_B=$1
				;;
			--)
				shift
				break
				;;
			*)
				log 0 "No such parameter: '$1'"
				exit "$EX_FAIL"
				;;
		esac
		shift
	done
	END_LOAD_ARG=("$@")
}

declare -a END_LOAD_ARG
load_arg "$@"
eval set -- "${END_LOAD_ARG[@]}"

# shellcheck disable=SC2119
load_config

################################################################################
# Start functions
set_colors
if [ $# -eq 1 ]; then
	log 3 "pid: $$"
	validate_inputs
	case "$1" in
		run)
			main
			;;
		*)
			log 0 "No such command: $1"
			log 0 "See --help for more details"
			exit "$EX_USAGE"
			;;
	esac
else
	log 0 "Bad, too many, or no command given:" "$@"
	log 0 "see --help"
	exit "$EX_USAGE"
fi
== ENDTEMPLATE ==
